\documentclass[12pt,a4paper,titlepage]{article}
\title{Confronto fra algoritmo LMS e Fast Deconvolution per la cancellazione del crosstalk} 
\author{Matteo Orlandini}
\date{\today}

\usepackage[english, italian]{babel} %the last declared language is the one used in the document
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{booktabs} %toprule, midrule, bottomrule
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{siunitx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[autolinebreaks, framed]{mcode} % matlab code
%\usepackage[numbered]{mcode} % matlab code
%inizio impostazioni bibliografia
\usepackage[autostyle,italian=guillemets]{csquotes} 
%autostyle adatta lo stile delle citazioni alla lingua corrente del documento;
%italian=guillemets racchiude automaticamente tra virgolette caporali
%i campi che prevedono le virgolette;
\usepackage[backend=biber, style=numeric, citestyle=numeric,maxcitenames=99,maxbibnames = 99]{biblatex}
%backend=biber dice a biblatex che s’intende usare Biber come motore bibliografico
%style:numeric Anno di pubblicazione: in fondo al riferimento.
%citestyle=numeric Riferimento: numerico ([1], [2], eccetera).
%fine impostazioni bibliografia

\usepackage{float}
\usepackage{hyperref}
\hypersetup{
	bookmarks=true,         % show bookmarks bar?
	unicode=false,          % non-Latin characters in Acrobat’s bookmarks
	pdftoolbar=true,        % show Acrobat’s toolbar?
	pdfmenubar=true,        % show Acrobat’s menu?
	pdffitwindow=false,     % window fit to page when opened
	pdfstartview={FitH},    % fits the width of the page to the window
	%pdftitle={Relazione di Reti di Sensori Wireless per IOT},    % title
	pdfauthor={Matteo Orlandini},     % author
	pdfsubject= {Confronto fra algoritmo LMS e Fast Deconvolution per la cancellazione del crosstalk},   % subject of the document
	pdfcreator={Matteo Orlandini},   % creator of the document
	%pdfproducer={Producer}, % producer of the document
	pdfpagemode={UseOutlines},
	%bookmarksopen,
	pdfstartview={FitH},
	colorlinks=false,       % false: boxed links; true: colored links
	linkcolor={red},
	citecolor={green},
	urlcolor={cyan}
} 

\lstdefinelanguage{cpp}{
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#},
                language=C++,
}

\renewcommand{\lstlistingname}{Codice}

\addbibresource{Bibliografia.bib}

\newcommand{\CoverName}{Cover}

\begin{document}

\begin{titlepage}
	
	\centering
	\includegraphics[width=.2\textwidth]{Immagini/univpmlogo}\par\vspace{1cm}
	{\scshape\LARGE Università Politecnica delle Marche\par}
	\vspace{1cm}
	{\scshape\Large Multirate Digital Signal Processing And Adaptive Filter Banks \par}
	\vspace{1.5cm}
	{\huge\bfseries Confronto fra algoritmo LMS e Fast Deconvolution per la cancellazione del crosstalk \par}
	\vspace{2cm}
	{\Large\itshape Matteo Orlandini e Jacopo Pagliuca\par}
	\vfill
	Prof.ssa Stefania \textsc{Cecchi}\\
	Dott.ssa Valeria \textsc{Bruschi}
	
	\vfill
	
	% Bottom of the page
	{\large \today\par}
\end{titlepage}

\thispagestyle{empty}
\tableofcontents

\newpage
\setcounter{page}{1}
\section{Introduzione}
\label{sec:Introduzione}
\clearpage

\section{Dataset}
\label{sec:Dataset}
Il dataset usato è composto ad un ampio set di \href{http://sound.media.mit.edu/resources/KEMAR/full.zip}{misurazioni della funzione di trasferimento relativa alla testa} (HRTF) di un microfono dummy-head KEMAR. Le misurazioni consistono nelle risposte impulsive dell'orecchio sinistro e destro di un altoparlante Realistic Optimus Pro 7 montato a 1,4 metri dal KEMAR. Sono state utilizzate sequenze binarie pseudo-casuali per ottenere le risposte impulsive a una frequenza di campionamento di \SI{44.1}{\kilo \hertz}. \cite{Gardner:HRTF}

Le misurazioni sono state effettuate nella camera anecoica del MIT. Il KEMAR è stato montato in posizione verticale su un giradischi motorizzato che può essere ruotato con precisione sotto il controllo del computer. L'altoparlante è stato montato su un supporto a braccio che ha consentito il posizionamento accurato dell'altoparlante a qualsiasi elevazione rispetto al KEMAR. Pertanto, le misurazioni sono state effettuate un'elevazione alla volta, impostando l'altoparlante all'altezza corretta e quindi ruotando il KEMAR su ciascun azimut.

I dati HRTF vengono archiviati nelle directory per elevazione. Ogni nome di directory ha il formato "elevEE", dove EE è l'angolo di elevazione. All'interno di ogni directory, il nome di ogni file ha il formato "XEEeAAAa.wav" dove X può essere "L" o "R" rispettivamente per la risposta dell'orecchio sinistro e destro, "EE" è l'angolo di elevazione della sorgente in gradi, da -40° a 90°, e AAA è l'azimut della sorgente in gradi, da 0° a 355°. Gli angoli di elevazione e azimut indicano la posizione della sorgente rispetto al KEMAR, in modo che, ad esempio, in corrispondenza dell'elevazione 0 e azimut 0 sia di fronte al KEMAR , l'elevazione 90 è direttamente sopra il KEMAR, elevazione 0 e azimut 90 è a destra del KEMAR. Ad esempio, il file "R-20e270a.wav" è la risposta dell'orecchio destro, con la sorgente 20 gradi sotto il piano orizzontale e 90 gradi a sinistra della testa.
\clearpage
\section{Descrizione teorica degli algoritmi}
\label{sec:descrizione_teorica}
\subsection{LMS}
\label{subsec:LMS_teoria}
Per la cancellazione del crosstalk l'algoritmo più comune è quello dell'LMS.
Nonostante sia semplice e accurato ha una veloce convergenza.
Una tipica situazione di ascolto con due altoparlanti con cancellazione del closstalk è rappresentata in figura...
La rappresentazione in frequenza dei segnali desiderati binaurali è indicata con $X_1$ e $X_2$ per suoni che raggiungono rispettivamente orecchio destro e sinistro.
Con $Y_1$ e $Y_2$ invece, si indicano i suoni che effettivamente raggiungono l'ascoltatore, attraversando il sistema.
Il sistema può essere rappresentato come:

\begin{equation}
\textbf{Y=CHX}
\end{equation}
ovvero
\begin{equation}
\begin{bmatrix}
Y_1\\
Y_2
\end{bmatrix}
=
\begin{bmatrix}
C_{11} & C_{12}\\
C_{21} & C_{22}
\end{bmatrix}
\begin{bmatrix}
H_{11} & H_{12}\\
H_{21} & H_{22}
\end{bmatrix}
\begin{bmatrix}
X_1\\
X_2
\end{bmatrix}
\end{equation}

Per avere il segnale in uscita uguale a quello desiderato $H$ dovrebbe essere l'inversa di $C$. La diretta inversa di $C$ però non garantisce la cancellazione del crosstalk in quanto gli elementi non soddisfano la condizione di fase minima.
La'approccio utilizzato è quindi quello dell'algoritmo LMS.
La precedente equazione viene riscritta come:

\begin{equation}
\begin{bmatrix}
Y_1\\
Y_2
\end{bmatrix}
\begin{bmatrix}
C_{11} X_1 & C_{12} X_1 & C_{11} X_2 & C_{12} X_2 \\ 
C_{21} X_1 & C_{22} X_1 & C_{21} X_2 & C_{22} X_2 \\ 
\end{bmatrix}
\begin{bmatrix}
H_{11}\\
H_{21}\\
H_{12}\\
H_{22}\\
\end{bmatrix}
\end{equation}

In generale, si può scrivere il filtraggio nell'$n$-esimo istante di un segnale $\mathbf{a[n]} = \left[a[n], a[n-1], \dots, a[n - M + 1]\right]^T$ con un filtro $\mathbf{b[n]} =  \left[b_{0}[n], b_{1}[n], \dots, b_{M-1}[n]\right]^T$ di lunghezza $M$ come
\begin{equation}\label{eq:filtraggio_prodotto_scalare}
y[n] = \sum_{j=0}^{M-1}b_{j}[n]a[n-j] = \mathbf{b}^T[\mathbf{n}] \cdot \mathbf{a}^T[\mathbf{n}].
\end{equation}

Il filtraggio dei segnali di riferimento $x_i[n]$ con le hrir $c_{lm}$ è dato dalla seguente equazione
\begin{equation}\label{eq:r_ilm}
r_{ilm}[n]=\sum_{j=0}^{M-1}c_{lm}[j]x_i[n-j].
\end{equation}

Si può applicare la formula~\eqref{eq:filtraggio_prodotto_scalare} all'equazione~\eqref{eq:r_ilm} per calcolare le $r_{ilm}[n]$ nel seguente modo:

\begin{equation}\label{eq:r_ilm_prodotto_scalare}
r_{ilm}[n]=\sum_{j=0}^{M-1}c_{lm,j}[n]x_i[n-j] = \mathbf{c_{lm}}^T[\mathbf{n}] \cdot \mathbf{x_i}^T[\mathbf{n}].
\end{equation}

Il segnale ricevuto ad ogni orecchio è dato da:
\begin{equation}\label{eq:y_i_lms}
y_i[n]=r_{1i1}[n] \circledast h_{11}[n]+r_{1i2}[n] \circledast h_{21}[n]+
r_{2i1}[n] \circledast h_{12}[n]+r_{2i2}[n] \circledast h_{22}[n]
\end{equation}
dove $i,l,m$ assumono i valori 1 o 2.
Il criterio dell'algoritmo LMS è la minimizzazione della funzione costo
\begin{equation}
J=E[e[n]^2]=E[(d[n]-y[n])^2]
\end{equation}
dove $e[n]$, $d[n]$ e $y[n]$ sono definiti come
\begin{equation}
e[n]=
\begin{bmatrix}
e_1[n]\\
e_2[n]
\end{bmatrix},
d[n]=
\begin{bmatrix}
d_1[n]\\
d_2[n]
\end{bmatrix},
y[n]=
\begin{bmatrix}
y_1[n]\\
y_2[n]
\end{bmatrix}
\end{equation}
La minimizzazione di $J$ avviene con il metodo steepest descend.
Nel dominio del tempo discreto il sistema si può scrivere come
\begin{equation}\label{eq:y_lms}
\begin{bmatrix}
	y_1[n]     \\
	y_2[n]    
\end{bmatrix}
= 
\begin{bmatrix}
	c_{11}[n] \circledast x_1[n]  &  c_{12}[n] \circledast x_1[n]  & c_{11}[n] \circledast x_2[n]  & c_{12}[n] \circledast x_2[n]    \\
	c_{21}[n] \circledast x_1[n]  &  c_{22}[n] \circledast x_1[n]  & c_{21}[n] \circledast x_2[n]  & c_{22}[n] \circledast x_2[n]     
\end{bmatrix} 
\circledast
\begin{bmatrix}
	h_{11}[n] \\
	h_{21}[n] \\
	h_{12}[n] \\
	h_{22}[n]  
\end{bmatrix}
\end{equation}
Usando~\eqref{eq:r_ilm}, l'equazione~\eqref{eq:y_lms} diventa
\begin{equation}\label{eq:y_lms2}
\begin{bmatrix}
	y_1[n]     \\
	y_2[n]    
\end{bmatrix}
= 
\begin{bmatrix}
	r_{111}[n]  &	r_{112}[n]  &  r_{211}[n]  &	r_{212}[n]    \\
	r_{121}[n]  &	r_{122}[n]  &  r_{221}[n]  &	r_{222}[n]    \\
\end{bmatrix} 
\circledast
\begin{bmatrix}
	h_{11}[n] \\
	h_{21}[n] \\
	h_{12}[n] \\
	h_{22}[n]  
\end{bmatrix} 
\end{equation}
Per ottenere l'errore si calcola la differenza fra il segnale desiderato è l'uscita effettiva.
\[
e_1^{(1)} = d_1 - (r_{111} \circledast h_{11} + r_{112} \circledast h_{21} + r_{211} \circledast h_{12} + r_{212} \circledast h_{22})
\]
l'aggiornamento avviene come di seguito:
\begin{equation}\label{eq:aggiornamento_lms}
h^{(k+1)} = h^{(k)} - \mu e_i^{(k)} \cdot \mathbf{r}_i^T
\end{equation}
dove $\mathbf{r}_i$ è l'i-esima riga della matrice che contiene le $r_{ilm}$ nell'equazione~\eqref{eq:y_lms2} e $e_i^{(k)}$ è l'errore k-esimo step e all'i-esima riga. Esplicitando l'equazione~\eqref{eq:aggiornamento_lms}, si ottiene
\[
\begin{split}
h_{11}^{(k+1)}[n] \leftarrow h_{11}^{(k)}[n] - \mu e_1^{(1)} \cdot r_{111}[n]\\
h_{21}^{(k+1)}[n] \leftarrow h_{21}^{(k)}[n] - \mu e_1^{(1)} \cdot r_{112}[n]\\
h_{12}^{(k+1)}[n] \leftarrow h_{12}^{(k)}[n] - \mu e_1^{(1)} \cdot r_{211}[n]\\
h_{22}^{(k+1)}[n] \leftarrow h_{22}^{(k)}[n] - \mu e_1^{(1)} \cdot r_{212}[n]
\end{split}
\]
Allo stesso modo, per il secondo canale l'errore è definito come:
\[e_2^{(2)} = d_2- (r_{121} \circledast h_{11} + r_{122} \circledast h_{21} + r_{221} \circledast h_{12} + r_{222} \circledast h_{22})
\]

\[
\begin{split}
h_{11}^{(k+1)}[n] \leftarrow h_{11}^{(k)}[n] - \mu e_2^{(2)} \cdot r_{121}[n]\\
h_{21}^{(k+1)}[n] \leftarrow h_{21}^{(k)}[n] - \mu e_2^{(2)} \cdot r_{122}[n]\\
h_{12}^{(k+1)}[n] \leftarrow h_{12}^{(k)}[n] - \mu e_2^{(2)} \cdot r_{221}[n]\\
h_{22}^{(k+1)}[n] \leftarrow h_{22}^{(k)}[n] - \mu e_2^{(2)} \cdot r_{222}[n]\\
\end{split}
\]

\subsection{Fast Deconvolution}
\label{subsec:FD_teoria}
La deconvoluzione~\cite{kirkeby:deconvolution_regularization}~\cite{kirkeby:deconvolution_analysis}~\cite{kirkeby:deconvolution_design}, nella sua forma più elementare, può essere descritta come il compito di calcolare l'input di un sistema a tempo discreto conoscendo il suo output. Di solito si presume che il sistema sia lineare e che la relazione input output sia nota con precisione. In acustica e audio, la deconvoluzione a singolo canale è particolarmente utile poiché può compensare la risposta di trasduttori imperfetti come cuffie, altoparlanti e amplificatori. La deconvoluzione multicanale è necessaria nella progettazione di sistemi di cancellazione della diafonia e sistemi di imaging di sorgenti virtuali.%~\cite{kirkeby:deconvolution_analysis}

Nel progetto siamo interessati alle tecniche di deconvoluzione allo scopo di progettare filtri digitali per la riproduzione del suono su due canali. Più specificamente, dato un set di altoparlanti S, l'obiettivo è riprodurre un campo sonoro desiderato nei punti R dello spazio nel modo più accurato possibile. Questo principio è applicato dai cosiddetti sistemi di cancellazione della diafonia che vengono utilizzati per riprodurre registrazioni binaurali su due altoparlanti. In questo caso, viene utilizzata una matrice $2 \times 2$ di filtri digitali per compensare sia la risposta ambientale che la risposta degli altoparlanti, e anche per annullare la diafonia dall'altoparlante sinistro all'orecchio destro e viceversa. Un problema correlato è quello di ottenere una perfetta ``dereverberazione'' della risposta di una stanza in una posizione del microfono utilizzando due filtri digitali per calcolare l'ingresso a due altoparlanti. La fast deconvolution un metodo molto veloce per calcolare una matrice di filtri digitali che può essere utilizzata per controllare le uscite di un impianto multicanale. Questo metodo è tipicamente più veloce di diversi ordini di grandezza rispetto ai metodi nel dominio del tempo. Combina i principi dell'inversione dei minimi quadrati nel dominio della frequenza e il metodo di regolarizzazione di ordine zero che viene tradizionalmente utilizzato quando ci si trova di fronte a un problema di inversione mal condizionata.%~\cite{kirkeby:deconvolution_regularization}

La regolarizzazione dipendente dalla frequenza viene utilizzata per prevenire picchi elevati nella risposta in ampiezza dei filtri ottimali. Un ritardo di modellazione viene utilizzato per garantire che la rete di cancellazione del cross-talk funzioni bene non solo in termini di ampiezza, ma anche in termini di fase. L'algoritmo presuppone che sia possibile utilizzare filtri ottimali lunghi, e funziona bene solo quando due parametri di regolarizzazione, un fattore di forma e un fattore di guadagno, sono impostati in modo appropriato. In pratica, i valori dei due parametri di regolarizzazione sono determinati più facilmente da esperimenti per tentativi.%~\cite{kirkeby:deconvolution_design}

Consideriamo una funzione di costo del tipo
\begin{equation}\label{funzione_costo_fd}
J = E + \beta V(f)
\end{equation}
dove $E$ è una misura dell'errore della pressione sonora
\begin{equation}\label{errore_fd}
E = | Y_1 - X_1 |^2  + | Y_2 - X_2 |^2
\end{equation}
e $V$ è una funzione della frequenza che indica il costo computazionale. Il numero $\beta \geq 0$ è un parametro di regolarizzazione che determina quanto peso
assegnare alla funzione $V$. Poiché non sappiamo a priori se la matrice $C$ è non singolare per determinate frequenze, la matrice $H$ di cancellazione del crosstalk può contenere valori molto alti. All'aumentare di $\beta$ da zero a infinito, $J$ cambia gradualmente dalla minimizzazione della sola funzione di errore $E$ alla minimizzazione dello sforzo computazionale $V$.

Siano $S$ i segnali trasferiti agli altoparlanti facendo passare il segnale $X$ attraverso la matrice di cancellazione del crosstalk $H$. Otteniamo
\begin{equation}
V(f) = S_b ^{+} S_b
\end{equation}
con
\begin{equation}
S_b = BS = BHX
\end{equation}
dove $B$ è una matrice $2 \times 2$ e il simbolo $+$ indica l'inversa generalizzata della matrice $S_b$. La soluzione approssimata della funzione $J$ è definita da 
\begin{equation}\label{eq:H_FD}
H(z) = \left[C^T (z^{-1}) C(z) + \beta B^T B)\right]^{-1} C^T(z^{-1})
\end{equation}
dove l'apice $T$ denota la trasposta della matrice. Se la matrice $B$ è uguale alla matrice identità $I$, si ottiene $S_b = S$, dunque l'equazione~\eqref{eq:H_FD} diventa
\begin{equation}\label{eq:H_FD2}
H(z) = \left[C^T (z^{-1}) C(z) + \beta I)\right]^{-1} C^T(z^{-1}) z^{-m}
\end{equation}
dove la componente $z^{-m}$ implementa un ritardo di $m$ campioni.

Le equazioni~\eqref{eq:H_FD} e~\eqref{eq:H_FD2} rappresentano una espressione di $H(z)$ nel dominio continuo della frequenza. Se viene usata una FFT a $N$ punti per campionare la risposta in frequenza $H(z)$, allora il valore di $H[k]$ è dato da
\begin{equation}\label{H_FD_3}
H[k] = \left[C^H[k] C[k] + \beta I)\right]^{-1} C^H[k]
\end{equation}
dove $k$ indica la $k$-esima frequenza corrispondente a $\exp(j2\pi k/N)$ e l'apice $H$ denota l'operatore Hermitiano che fa la trasposta coniugata del suo argomento. Dall'equazione~\eqref{H_FD_3} si può osservare che ponendo $\beta = 0$ si ottiene $H = C^{-1}$. In questo caso, poiché $Y = CHX = C C^{-1} X = IX = X$, si ottiene in uscita il segnale d'ingresso.

Per calcolare la risposta impulsiva del filtro occorre seguire i seguenti passi:
\begin{enumerate}
\item si calcola la matrice $2 \times 2$ $C[k]$ tramite una FFT delle risposte impulsive $c_{ij}[n]$ con $i = 1, 2$ e $j = 1, 2$. Ad esempio, $C_{11}[k]$ contiene l'ampiezza della $k$-esima armonica della FFT di $c_{11}$,
\item si calcola $H[k]$ usando la formula~\eqref{H_FD_3},
\item si calcola $h[n]$ facendo una FFT inversa a $N$ punti,
\item si implementa uno shift ciclico di $m$ campioni per ogni elemento di $h_{ij}[n]$ con $i = 1, 2$ e $j = 1, 2$.
\end{enumerate}

Dato che l'uscita $Y$ è data da
\begin{equation}\label{eq:y_matrix}
Y = CHX = 
\begin{bmatrix}
C_{11} X_1 & C_{12} X_1 & C_{11} X_2 & C_{12} X_2 \\ 
C_{21} X_1 & C_{22} X_1 & C_{21} X_2 & C_{22} X_2 \\ 
\end{bmatrix}
\begin{bmatrix}
H_{11}\\
H_{21}\\
H_{12}\\
H_{22}\\
\end{bmatrix}
\end{equation}
nell'implementazione pratica non si può calcolare tutta l'uscita con la sola operazione matriciale~\eqref{eq:y_matrix}, occorre usare la tecnica dell'overlap and save per filtrare l'ingresso $X$ con i filtri $C$ e $H$. L'overlap and save è utile per eseguire un filtraggio in real time con un filtro a risposta impulsiva finita. Questa tecnica viene usata per fare la convoluzione a blocchi tra un segnale di ingresso $x[n]$ molto lungo e un filtro FIR $h[n]$:
\begin{equation}
y[n] = x[n] * h[n] = \sum_{m=-\infty}^{+\infty} {h[m] \cdot x[n-m]} = \sum_{m=1}^{M} {h[m] \cdot x[n-m]}
\end{equation}
poiché $h[m]$ = 0 per $m \in [1, M]$.

L'overlap and save permette di calcolare dei blocchi di $y[n]$ di lunghezza $L$ e concatenarli insieme per formare il segnale di uscita completo. Si definisce il $k$-esimo blocco d'ingresso come
\begin{equation}
x_k[n] = 
\begin{cases}
x[n+kL], & 1 \leq n \leq L + M - 1\\
0 & \text{altrove}
\end{cases}
\end{equation}
quindi il $k$-esimo blocco di uscita è dato da 
\begin{equation}
y_k[n] = x_k[n] * h[n] = \sum_{m=1}^{M} {h[m] \cdot x_k[n-m]}.
\end{equation}
Si può definire l'uscita per $kL + M \leq n \leq KL + L +M - 1$, o in modo equivalente per $M \leq n - kL \leq L + M - 1$, nel seguente modo:
\begin{equation}
y[n] = \sum_{m=1}^{M} {h[m] \cdot x_k[n-kL-m]} = y_k[n - kL].
\end{equation}
L'implementazione dell'overlap and save con un filtro composto da $(L + M - 1)$ tappi consiste nei seguenti passi:
\begin{enumerate}
\item si divide il segnale di ingresso in blocchi di lunghezza $L$
\item nel caso del primo blocco si aggiungono $M - 1$ zeri all'inizio, altrimenti si aggiungono all'inizio del blocco gli ultimi $M - 1$ campioni del blocco precedente, come mostrato in figura~\ref{fig:ols},
\item si fa la FFT a $L + M - 1$ punti del $k$-esimo blocco di ingresso,
\item si fa la FFT a $L + M - 1$ punti del filtro FIR $h[n]$
\item si moltiplicano le FFT calcolate per trovare la risposta in frequenza del $k$-esimo blocco di uscita,
\item si fa la FFT inversa a $L + M - 1$ punti del $k$-esimo blocco di uscita,
\item si scartano i primi $M - 1$ punti, ottenendo il $k$-esimo blocco in uscita di lunghezza $L$, come mostrato nei blocchi di uscita $y_k$ di figura~\ref{fig:ols}.
\end{enumerate}

Un'implementazione più efficiente è invece quella descritta di seguito, in cui i primi due punti precedentemente elencati rimangono uguali:
\begin{enumerate}\setcounter{enumi}{2}
\item si fa la FFT a $2 \cdot (L + M - 1)$ punti del $k$-esimo e del $(k-1)$-esimo blocco di ingresso lunghi rispettivamente $(L + M - 1)$ campioni,
\item si fa la FFT a $2 \cdot (L + M - 1)$ punti del filtro FIR $h[n]$ con un padding di $(L + M - 1)$ zeri
\item si moltiplicano le FFT calcolate per trovare la FFT del blocco di uscita,
\item si fa la FFT inversa del blocco di uscita,
\item si scartano i primi $L + M - 1$ punti nel tempo dell'uscita.
\end{enumerate}

\begin{figure}[h]
	\centering	
	\includegraphics[width=.7\textwidth]{Immagini/ols}
	\caption{Metodo Overlap and Save}
	\label{fig:ols}
\end{figure}

\clearpage

\section{Codice Matlab}
\label{sec:codice_matlab}
\subsection{LMS}
\label{subsec:codice_matlab_lms}
Nel codice dell'algoritmo LMS in Matlab si carica il file audio in formato wav ``Daft Punk - Get Lucky\_cut.wav''. Poiché questo formato contiene i campioni del canale sinistro e di quello destro, si dividono i due canali salvando il primo nella variabile \texttt{x1} e il secondo in \texttt{x2}.

\begin{lstlisting}[label=code:caricamento_audio_lms, caption=Caricamento del file audio, captionpos=b]
[x, Fsample] = audioread('Daft Punk - Get Lucky_cut.wav');
x1 = x(:, 1);
x2 = x(:, 2);
\end{lstlisting}

Allo stesso modo vendono caricate le quattro HRIR \texttt{c11}, \texttt{c12}, \texttt{c21} e \texttt{c22}.

\begin{lstlisting}[label=code:caricamento_hrir_lms, caption=Caricamento delle HRIR, captionpos=b]
% c11: HRIR left loudspeaker - left ear
[c11,Fs] = audioread('HRTF_measurements/elev0/L0e330a.wav'); 
% c12: HRIR right loudspeaker - left ear
[c12,~] = audioread('HRTF_measurements/elev0/L0e030a.wav');     
% c21: HRIR left loudspeaker - right ear
[c21,~] = audioread('HRTF_measurements/elev0/R0e330a.wav');    
% c22: HRIR right loudspeaker - righ ear
[c22,~] = audioread('HRTF_measurements/elev0/R0e030a.wav');  
\end{lstlisting}

Viene salvata la lunghezza dei filtri $c_{11}$, $c_{12}$, $c_{21}$ e $c_{22}$ nella variabile \texttt{M}. Si ha che $M = 512$ e si imposta il ritardo temporale \texttt{tau} pari a \texttt{M}. Conoscendo il valore del ritardo temporale, è possibile costruire i due segnali desiderati \texttt{d1} e \texttt{d2} mettendo \texttt{tau} zeri all'inizio del vettore d'ingresso.

\begin{lstlisting}[label=code:segnale_desiderato_lms, caption=Costruzione del segnale desiderato, captionpos=b]
M = length(c11);      % lunghezza dei filtri c11, c12, c21, c22
% il segnale desiderato e' x ritardato di tau campioni
tau = M;   % ritardo temporale
d1 = [zeros(tau,1); x1(1:end-tau)]; % segnale desiderato 1 (left)
d2 = [zeros(tau,1); x2(1:end-tau)]; % segnale desiderato 2 (right)
\end{lstlisting}

Vengono inizializzati i vettori \texttt{y1} e \texttt{y2} di uscita, i vettori \texttt{e1} e \texttt{e2} che contengono l'errore per i due canali, i vettori \texttt{r\ped{ilm}} che contengono il filtraggio di \texttt{x1} e \texttt{x2} con \texttt{c11}, \texttt{c12}, \texttt{c21} e \texttt{c22}. Questi vettori sono tutti di lunghezza pari a quella de segnale x, cioè \texttt{L}.

\begin{lstlisting}[label=code:inizializzazione_vettori_L, caption=Inizializzazione dei vettori di lunghezza L, captionpos=b]
L = length(x1);
y1 = zeros(L,1);  % output 1 (left)
y2 = zeros(L,1);  % output 2 (right)

e1 = zeros(L,1);  % errore 1 (left)
e2 = zeros(L,1);  % errore 2 (right)

r111 = zeros(L,1);    % uscita di x1 filtrato da c11 per output y1
r112 = zeros(L,1);    % uscita di x1 filtrato da c12 per output y1
r211 = zeros(L,1);    % uscita di x2 filtrato da c11 per output y1
r212 = zeros(L,1);    % uscita di x2 filtrato da c12 per output y1
r222 = zeros(L,1);    % uscita di x2 filtrato da c22 per output y2
r221 = zeros(L,1);    % uscita di x2 filtrato da c21 per output y2
r122 = zeros(L,1);    % uscita di x1 filtrato da c22 per output y2
r121 = zeros(L,1);    % uscita di x1 filtrato da c21 per output y2
\end{lstlisting}

Successivamente, vengono inizializzati i vettori di lunghezza \texttt{M}, le variabili \texttt{h11},  \texttt{h12},  \texttt{h21} e  \texttt{h22} contengono i filtri di ricostruzione, i buffer \texttt{x1buff} e \texttt{x2buff} necessari per il filtraggio con i c e i buffer delle uscite $r_{ilm}$ dove $i, l, m = 0,1$.

\begin{lstlisting}[label=code:inizializzazione_vettori_M, caption=Inizializzazione dei vettori di lunghezza M, captionpos=b]
x1buff = zeros(M, 1);
x2buff = zeros(M, 1);

r111buff = zeros(M,1);    
r112buff = zeros(M,1);    
r211buff = zeros(M,1);  
r212buff = zeros(M,1);    
r222buff = zeros(M,1);    
r221buff = zeros(M,1);    
r122buff = zeros(M,1);   
r121buff = zeros(M,1);  
\end{lstlisting}

Nel codice~\ref{code:filtraggio_x_c} viene usato un $\mu = 10^{-3}$ e viene implementata l'equazione~\eqref{eq:r_ilm_prodotto_scalare} che effettua il filtraggio tra le hrir e il segnale di ingresso. Per fare questo, si utilizza un buffer che aggiunge in testa il campione entrante invertendo il segnale di ingresso. Facendo il prodotto scalare dei buffer di ingresso con le rispettive $c_{lm}$, si ottiene il filtraggio desiderato.

\begin{lstlisting}[label=code:filtraggio_x_c, caption=Filtraggio del segnale di ingresso con le hrir, captionpos=b]
mu = 1e-3; 
for n = 1:L
    x1buff = [x1(n); x1buff(1:end-1)];
    x2buff = [x2(n); x2buff(1:end-1)];
   
    r111(n) = c11'*x1buff;
    r112(n) = c12'*x1buff;
    r211(n) = c11'*x2buff;
    r212(n) = c12'*x2buff;
    r222(n) = c22'*x2buff;
    r221(n) = c21'*x2buff;
    r122(n) = c22'*x1buff;
    r121(n) = c21'*x1buff;
\end{lstlisting}

L'equazione~\eqref{eq:r_ilm_prodotto_scalare} viene nuovamente applicata nel codice~\ref{code:filtraggio_r_h} per calcolare le uscite. I segnali intermedi $r_{ilm}$ vanno a costituire un buffer e attraversano i filtri $h$. Le quattro uscite dei filtri $h$ vengono infine sommate per ottenere \texttt{y1} e \texttt{y2}, come mostrato nell'equazione~\eqref{eq:y_i_lms}.

\begin{lstlisting}[label=code:filtraggio_r_h, caption=Calcolo delle uscite, captionpos=b]
    r111buff = [r111(n); r111buff(1:end-1)];
    r112buff = [r112(n); r112buff(1:end-1)];
    r211buff = [r211(n); r211buff(1:end-1)];
    r212buff = [r212(n); r212buff(1:end-1)];
    r222buff = [r222(n); r222buff(1:end-1)];
    r221buff = [r221(n); r221buff(1:end-1)];
    r122buff = [r122(n); r122buff(1:end-1)];
    r121buff = [r121(n); r121buff(1:end-1)];
    
    y1(n) = h11'*r111buff+h21'*r112buff+h12'*r211buff+h22'*r212buff;
    y2(n) = h11'*r121buff+h21'*r122buff+h12'*r221buff+h22'*r222buff;
\end{lstlisting}

Viene quindi calcolato l'errore come la differenza fra il segnale desiderato e le uscite.

\begin{lstlisting}[label=code:calcolo_errore, caption=Calcolo dell'errore, captionpos=b]
    e1(n) = d1(n)-y1(n);
    e2(n) = d2(n)-y2(n);
\end{lstlisting}    


I valori dell'errore vengono poi utilizzati per aggiornare i tappi dei filtri \texttt{h11}, \texttt{h12}, \texttt{h21} e \texttt{h22} tramite un altro ciclo for, utilizzando la formula~\eqref{eq:aggiornamento_lms}.

\begin{lstlisting}[label=code:aggiornamento_filtro_lms, caption=Aggiornamento del filtro, captionpos=b]
    for k = 1:M
        h11(k) = h11(k)+mu*(e1(n)*r111buff(k)+e2(n)*r121buff(k));
        h12(k) = h12(k)+mu*(e1(n)*r211buff(k)+e2(n)*r221buff(k));
        h21(k) = h21(k)+mu*(e1(n)*r112buff(k)+e2(n)*r122buff(k));
        h22(k) = h22(k)+mu*(e1(n)*r212buff(k)+e2(n)*r222buff(k));
    end
end
\end{lstlisting}

\subsection{Fast Deconvolution}
\label{subsec:codice_matlab_fd}
Nella Fast Deconvolution, come per il codice della LMS, si carica il file audio e le risposte impulsive \texttt{c11}, \texttt{c12}, \texttt{c21} e \texttt{c22} come mostrato nei codici~\ref{code:caricamento_audio_lms} e~\ref{code:caricamento_hrir_lms}. A differenza dell'algoritmo LMS, nella Fast Deconvolution si usa un overlap and save quindi occorre scegliere come dividere in blocchi il segnale di ingresso. Si implementa l'overlap and save come descritto nel capitolo~\ref{subsec:FD_teoria}, con dei blocchi di lunghezza $L = 4096$, pari alla lunghezza di default del frame di Nu-Tech, e un overlap al 50\%, quindi $M = L/2 = 2048$. La lunghezza totale del frame con overlap sarà quindi $\text{fs} = L + M - 1 = 4096+2048-1 = 6143$, per una FFT efficiente si sceglie la potenza di 2 più vicina a $6143$, quindi $\text{fftLen} = 2^{13} = 8192$.

\begin{lstlisting}[label=code:parametri_ols, caption=Parametri overlap and save, captionpos=b]
L = 4096;
M = L/2;
fs = L + M - 1; % frame size
fftLen = 2.^nextpow2(fs);
\end{lstlisting}

Per eseguire l'overlap and save è necessaria la FFT di lunghezza pari a \texttt{fftLen} dei filtri C e H. Poiché i filtri H non sono ancora stati calcolati, vengono inizializzati a zero.

\begin{lstlisting}[label=code:fft_hrir, caption=FFT delle risposte impulsive del canale e inizializzazione dei filtri di cancellazione del crosstalk, captionpos=b]
C11 = fft(c11, fftLen);     % HRTF left loudspeaker - left ear
C12 = fft(c12, fftLen);     % HRTF right loudspeaker - left ear
C21 = fft(c21, fftLen);     % HRTF left loudspeaker - right ear
C22 = fft(c22, fftLen);     % HRTF right loudspeaker - right ear

H11 = zeros(fftLen,1);     % filtro di cancellazione del crosstalk input 1 output 1
H12 = zeros(fftLen,1);     % filtro di cancellazione del crosstalk input 2 output 1
H21 = zeros(fftLen,1);     % filtro di cancellazione del crosstalk input 1 output 2
H22 = zeros(fftLen,1);     % filtro di cancellazione del crosstalk input 2 output 2
\end{lstlisting}

L'implementazione dell'equazione~\eqref{eq:H_FD2} è mostrato nel codice~\ref{code:calcolo_h_fd} con $\beta = 0.1$ e $B = I$, dove $I$ è la matrice identità. Per ogni frequenza $k$ dei filtri $C_{11}$, $C_{12}$, $C_{21}$ e $C_{22}$, composti da \texttt{fftLen} punti in frequenza, viene costruita una matrice $C [k]$ nel seguente modo:
\begin{equation*}
C [k] =
\begin{bmatrix}
C_{11}[k]	& C_{12}[k]\\
C_{21}[k]	& C_{22}[k]
\end{bmatrix}.
\end{equation*}
Per trovare i filtri $H_{11}$, $H_{12}$, $H_{21}$ e $H_{22}$ si calcola la matrice $H$ come mostrato nell'equazione~\eqref{eq:H_FD2} dove $H$ è una matrice $2 \times 2$ costruita nel seguente modo:
\begin{equation*}
H [k] =
\begin{bmatrix}
H_{11}[k]	& H_{12}[k]\\
H_{21}[k]	& H_{22}[k]
\end{bmatrix}.
\end{equation*}
I filtri $H_{11}$, $H_{12}$, $H_{21}$ e $H_{22}$ sono presi dagli elementi della matrice $H$.

\begin{lstlisting}[label=code:calcolo_h_fd, caption=Calcolo dei filtri di cancellazione del crosstalk, captionpos=b]
beta = 0.1;
B = [1 0; 0 1];
for k = 1:length(C11)
    C = [C11(k) C12(k); C21(k) C22(k)];
    H = (C'*C+beta*(B'*B))^(-1)*C'; 
    H11(k) = H(1, 1);
    H12(k) = H(1, 2);
    H21(k) = H(2, 1);
    H22(k) = H(2, 2);
end
\end{lstlisting}

Dopo aver calcolato i filtri $H$, si procede con l'implementazione dell'overlap and save inizializzando due buffer \texttt{x1Buff} e \texttt{x2Buff} con \texttt{fs} zeri.

\begin{lstlisting}[label=code:buffer_ols, caption=Inizializzazione dei buffer per l'overlap and save, captionpos=b]
x1Buff = zeros(fs, 1);
x2Buff = zeros(fs, 1);
\end{lstlisting}

Successivamente si divide il segnale di ingresso, lungo \texttt{nPoints}, in blocchi di lunghezza \texttt{L}, risultando in un numero di blocchi pari a \texttt{nPoints/L}. Poiché non sappiamo a priori se questo valore è intero, lo si approssima per difetto usando la funzione \texttt{floor} di Matlab. Per l'\texttt{i}-esimo blocco si copiano \texttt{L} campioni del segnale di ingresso nel buffer dall'indice $M$ in poi, come mostrato in figura~\ref{fig:ols}.

\begin{lstlisting}[label=code:ols1, caption=Copia di L campioni del segnale di ingresso nel buffer, captionpos=b]
nPoints = length(x1);
for i = 1 : floor(nPoints/L)
    copy L values of x vector into the buffer from M onwards
    x1Buff(fs - L + 1 : fs) = x1((i - 1) * L + 1 : i * L); 
    x2Buff(fs - L + 1 : fs) = x2((i - 1) * L + 1 : i * L); 
\end{lstlisting}

Dopo aver riempito il buffer, si fa la FFT a \texttt{fftLen} punti del buffer di ingresso.

\begin{lstlisting}[label=code:ols2, caption=FFT del buffer di ingresso, captionpos=b]
	X1BUFF = fft(x1Buff, fftLen);
	X2BUFF = fft(x2Buff, fftLen);
\end{lstlisting}

Si calcola il buffer di uscita in frequenza implementando l'equazione~\eqref{eq:y_matrix} come mostrato nel codice~\ref{code:ols3}.

\begin{lstlisting}[label=code:ols3, caption=Calcolo del buffer di uscita in frequenza, captionpos=b]
	Y1BUFF = (C11.*H11+C12.*H21).*X1BUFF+(C11.*H12+C12.*H22).*X2BUFF;
	Y2BUFF = (C21.*H11+C22.*H21).*X1BUFF+(C21.*H12+C22.*H22).*X2BUFF;
\end{lstlisting}
    
Usando il buffer di uscita in frequenza, si calcola la IFFT e si prendono solamente i valori reali.

\begin{lstlisting}[label=code:ols4, caption=IFFT del buffer di uscita, captionpos=b]
	y1Buff = real(ifft(Y1BUFF));
	y2Buff = real(ifft(Y2BUFF));
\end{lstlisting}  

L'aggiornamento dell'uscita avviene scartando i primi $M - 1$ campioni e dunque prendendo gli ultimi $L$ campioni del buffer precedentemente calcolato.

\begin{lstlisting}[label=code:ols5, caption=Aggiornamento dell'uscita, captionpos=b]
	% discard first M - 1 values
	y1((i-1) * L + 1 : i * L) = y1Buff(fs - L + 1 : fs); 
	y2((i-1) * L + 1 : i * L) = y2Buff(fs - L + 1 : fs); 
\end{lstlisting}  

Infine, si aggiornano i buffer di ingresso prendendo gli ultimi $M - 1$ punti del buffer di ingresso precedente e mettendoli all'inizio del buffer di ingresso successivo.

\begin{lstlisting}[label=code:ols6, caption=Aggiornamento del buffer di ingresso, captionpos=b, language=matlabfloz]
    % first M - 1 values of the new vector must be the last ones of the previous array
    x1Buff(1 : M - 1) = x1Buff(fs - M + 2 : fs); 
    x2Buff(1 : M - 1) = x2Buff(fs - M + 2 : fs); 
end
\end{lstlisting}  

\clearpage

\section{Codice C}
\label{sec:codice_c}
\subsection{LMS}
\label{sec:codice_c_lms}
Nella libreria \texttt{Plugin.h} viene inizialmente definito il nome del Nuts come ``LMS Filter''.

\begin{lstlisting}[language=cpp]
#define NUTS_NAME	"LMS Filter"
\end{lstlisting}
Nella classe \texttt{class PlugIn :	public LEEffect} vengono definite le variabili che saranno utilizzate nell'algoritmo.

Le variabili sono le stesse usate nel codice Matlab in \ref{code:inizializzazione_vettori_L} e \ref{code:inizializzazione_vettori_M}.
\begin{lstlisting}[language=cpp]
private:

	int FrameSize, SampleRate;
	int M, L, tau;
	double mu;
	double* x1, * x2, * d1, * d2, * y1, * y2, * e1, * e2, * x1buff, * x2buff;
	double* c11, * c12, * c21, * c22;
	double* h11, * h12, * h21, * h22;
	double* r111, * r112, * r211, * r212, * r222, * r221, * r122, * r121;
	double* r111buff, * r112buff, * r211buff, * r212buff, * r222buff, * r221buff, * r122buff, * r121buff;
\end{lstlisting}
Nel file \texttt{PlugIn.cpp} sono presenti le funzioni:
\begin{itemize}
\item Costruttore della classe Plugin : viene chiamata quando il NUTS viene caricato sulla board del NUTECH
\item Funzione di inizializzazione: viene chiamata quando si lancia la riproduzione con il tasto START
\item Funzione di elaborazione: all’interno di questa funzione va messa la parte di elaborazione real time del segnale
\item Funzione di deinizializzazione: viene chiamata quando si seleziona il tasto STOP
\item Distruttore della classe
Plugin : viene chiamata quando il NUTS viene eliminato dalla board del NUTECH
\end{itemize}
Nel costruttore vengono inizializzate a zero le varibile precedentemente definite.
Framesize e Samplerate vengono ricavati dagli ingressi del blocco che vengono impostati pari a due allo stesso modo delle uscite.
\begin{lstlisting}[language=cpp]
PlugIn::PlugIn(InterfaceType _CBFunction,void * _PlugRef,HWND ParentDlg): LEEffect(_CBFunction,_PlugRef,ParentDlg)
{
	FrameSize = CBFunction(this,NUTS_GET_FS_SR,0,(LPVOID)AUDIOPROC);
	SampleRate = CBFunction(this,NUTS_GET_FS_SR,1,(LPVOID)AUDIOPROC);

	LESetNumInput(2);
	LESetNumOutput(2);
	
	M = 512;	// filter length
	tau = M;
	mu = 1e-4;

	y1 = 0;
	y2 = 0;

	x1 = 0;
	x2 = 0;

	x1buff = 0;
	x2buff = 0;
	
	e1 = 0;
	e2 = 0;

	d1 = 0;
	d2 = 0;

	c11 = 0;
	c12 = 0;
	c21 = 0;
	c22 = 0;

	h11 = 0;
	h12 = 0;
	h21 = 0;
	h22 = 0;
	
	r111 = 0;
	r112 = 0;
	r211 = 0;
	r212 = 0;
	r222 = 0;
	r221 = 0;
	r122 = 0;
	r121 = 0;

	r111buff = 0;
	r112buff = 0;
	r121buff = 0;
	r122buff = 0;
	r211buff = 0;
	r212buff = 0;
	r221buff = 0;
	r222buff = 0;

	bufferNumber = 0;
}
\end{lstlisting}
Nella funzione di inizializzazione vengono allocate le variabili.
\begin{lstlisting}[language=cpp]
void __stdcall PlugIn::LEPlugin_Init()
{
	if (y1 == 0)
	{
		y1 = ippsMalloc_64f(FrameSize);
		ippsZero_64f(y1, FrameSize);
	}
\end{lstlisting}
Inoltre vegono caricati i tappi dei filtri HRIR tramite la funzione \texttt{read\_dat} presente in \texttt{myLib.cpp}.
\begin{lstlisting}[language=cpp]
	// load filter taps
	read_dat("c11.dat", c11, M);

	read_dat("c12.dat", c12, M);

	read_dat("c21.dat", c21, M);

	read_dat("c22.dat", c22, M);
\end{lstlisting}
Nella funzione Process avviene l'algoritmo vero e proprio. Questa funzione viene chiamata per ogni frame dell'ingresso e produce il corrispondente frame in uscita.
Gli ingressi e le uscite vengono quindi caricati in variabili temporanee in modo da poter essere elaborate.
Il vettore del segnale desiderato viene creato ritardando l'ingresso di \texttt{tau} campioni.
L'ingresso viene copiato nelle variabili \texttt{x1} e \texttt{x2} e normalizzato in ampiezza dividendo per 32768.
I vettori di uscita \texttt{y1} e \texttt{y2} vengono invece posti pari a zero.
\begin{lstlisting}[language=cpp]
int __stdcall PlugIn::LEPlugin_Process(PinType **Input,PinType **Output,LPVOID ExtraInfo)
{ 
	double* InputData1 = ((double*)Input[0]->DataBuffer);
	double* OutputData1 = ((double*)Output[0]->DataBuffer);
	double* InputData2 = ((double*)Input[1]->DataBuffer);
	double* OutputData2 = ((double*)Output[1]->DataBuffer);
	
	bufferNumber++;

	// d1[0:tau] = x1[end - tau:end];
	ippsCopy_64f(x1 + FrameSize - tau, d1, tau);
	// copy InputData1 to x1
	ippsCopy_64f(InputData1, x1, FrameSize);
	// divide each element of the vector x1 by 32768 and store the result in x1
	ippsDivC_64f_I(32768.0, x1, FrameSize);
	//d1[tau + 1:end] = x1[0:FrameSize - tau];	
	ippsCopy_64f(x1, d1 + tau, FrameSize - tau);
	// d2[0:tau] = x2[end - tau:end];
	ippsCopy_64f(x2 + FrameSize - tau, d2, tau);
	// copy InputData2 to x2
	ippsCopy_64f(InputData2, x2, FrameSize);
	// divide each element of the vector x2 by 32768 and store the result in x2
	ippsDivC_64f_I(32768.0, x2, FrameSize);
	//d2[tau + 1:end] = x2[0:FrameSize - tau];	
	ippsCopy_64f(x2, d2 + tau, FrameSize - tau);
	
	// initialize y1 and y2 with zeros
	ippsZero_64f(y1, FrameSize);
	ippsZero_64f(y2, FrameSize);
\end{lstlisting}
Il ciclo for corrisponde a quello usato in Matlab: vengono creati dei vettori di buffer temporanei e il segnale di ingresso viene elaborato un campione alla volta.
Moltiplicando il buffer di ingresso per i filtri $c_{ij}$ si ottengono i segnali $r_{ijl}$ intermedi.
\begin{lstlisting}[language=cpp]
	for (int i = 0; i < FrameSize; i++)
	{
		ippsMove_64f(x1buff, x1buff + 1, M - 1);
		x1buff[0] = x1[i];

		ippsMove_64f(x2buff, x2buff + 1, M - 1);
		x2buff[0] = x2[i];

		ippsDotProd_64f(c11, x1buff, M, &(r111[i]));
		ippsDotProd_64f(c12, x1buff, M, &(r112[i]));
		ippsDotProd_64f(c11, x2buff, M, &(r211[i]));
		ippsDotProd_64f(c12, x2buff, M, &(r212[i]));
		ippsDotProd_64f(c22, x2buff, M, &(r222[i]));
		ippsDotProd_64f(c21, x2buff, M, &(r221[i]));
		ippsDotProd_64f(c22, x1buff, M, &(r122[i]));
		ippsDotProd_64f(c21, x1buff, M, &(r121[i]));
\end{lstlisting}
A questo punto sono i segnali $r_{ijl}$ ad essere inseriti nel buffer. Moltiplicando ognuno di essi per $h_{ij}$ e sommando le 4 componenti si ottengono i segnali di uscita \texttt{y1} e \texttt{y2}.
\begin{lstlisting}[language=cpp]
		ippsMove_64f(r111buff, r111buff + 1, M - 1);
		r111buff[0] = r111[i];

		ippsMove_64f(r112buff, r112buff + 1, M - 1);
		r112buff[0] = r112[i];

		ippsMove_64f(r121buff, r121buff + 1, M - 1);
		r121buff[0] = r121[i];

		ippsMove_64f(r122buff, r122buff + 1, M - 1);
		r122buff[0] = r122[i];

		ippsMove_64f(r211buff, r211buff + 1, M - 1);
		r211buff[0] = r211[i];

		ippsMove_64f(r212buff, r212buff + 1, M - 1);
		r212buff[0] = r212[i];

		ippsMove_64f(r221buff, r221buff + 1, M - 1);
		r221buff[0] = r221[i];

		ippsMove_64f(r222buff, r222buff + 1, M - 1);
		r222buff[0] = r222[i];

		double ytmp = 0.0;
		ippsDotProd_64f(h11, r111buff, M, y1 + i);
		// y1[i] = y1[i] + ytmp;

		ippsDotProd_64f(h21, r112buff, M, &ytmp);
		y1[i] = y1[i] + ytmp;
		//ippsAddC_64f_I(ytmp, y1 + i, 1);

		ippsDotProd_64f(h12, r211buff, M, &ytmp);
		y1[i] = y1[i] + ytmp;
		//ippsAddC_64f_I(ytmp, y1 + i, 1);

		ippsDotProd_64f(h22, r212buff, M, &ytmp);
		y1[i] = y1[i] + ytmp;
		//ippsAddC_64f_I(ytmp, y1 + i, 1);

		ippsDotProd_64f(h11, r121buff, M, y2 + i);
		//y2[i] = y2[i] + ytmp;

		ippsDotProd_64f(h21, r122buff, M, &ytmp);
		y2[i] = y2[i] + ytmp;
		//ippsAddC_64f_I(ytmp, y2 + i, 1);

		ippsDotProd_64f(h12, r221buff, M, &ytmp);
		y2[i] = y2[i] + ytmp;
		//ippsAddC_64f_I(ytmp, y2 + i, 1);

		ippsDotProd_64f(h22, r222buff, M, &ytmp);
		y2[i] = y2[i] + ytmp;
		//ippsAddC_64f_I(ytmp, y2 + i, 1);
\end{lstlisting}
L'errore viene calcolato per ogni campione tramite la differenza fra il segnale desiderato e quello ottenuto.
\begin{lstlisting}[language=cpp]
		e1[i] = d1[i] - y1[i];
		e2[i] = d2[i] - y2[i];
\end{lstlisting}
I filtri h vengono poi aggiornati analogamente a \ref{code:aggiornamento_filtro_lms} tramite il metodo steepest descend.
\begin{lstlisting}[language=cpp]
		for (int j = 0; j < M; j++)
		{
			h11[j] = h11[j] + mu * (e1[i] * r111buff[j] + e2[i] * r121buff[j]);
			h12[j] = h12[j] + mu * (e1[i] * r211buff[j] + e2[i] * r221buff[j]);
			h21[j] = h21[j] + mu * (e1[i] * r112buff[j] + e2[i] * r122buff[j]);
			h22[j] = h22[j] + mu * (e1[i] * r212buff[j] + e2[i] * r222buff[j]);
		}	
	}
\end{lstlisting}
Il vettore in uscita viene quindi di nuovo riportate in \texttt{OutputData1} e \texttt{OutputData2} dopo essere stato scalato per 32768.
\begin{lstlisting}[language=cpp]
	// multiply each element of the vector y1 by a 32768 and store the result in y1
	ippsMulC_64f_I(32768.0, y1, FrameSize);
	// copy y1 to OutputData1
	ippsCopy_64f(y1, OutputData1, FrameSize);
	// multiply each element of the vector y2 by a 32768 and store the result in y2
	ippsMulC_64f_I(32768.0, y2, FrameSize);
	// copy y2 to OutputData2
	ippsCopy_64f(y2, OutputData2, FrameSize);
	return COMPLETED;
}
\end{lstlisting}
Nella funzione Delete vengono liberate dalla memoria tutte le variabili che erano state allocate nella Init.
\begin{lstlisting}[language=cpp]
void __stdcall PlugIn::LEPlugin_Delete()
{
	if (y1 != 0)
	{
		ippsFree(y1);
		y1 = 0;
	}
\end{lstlisting}

\subsection{Fast Deconvolution}
\label{sec:codice_c_fd}
Nella libreria \texttt{Plugin.h} viene inizialmente definito il nome del Nuts come ``Fast Deconvolution''.

\begin{lstlisting}[language=cpp]
#define NUTS_NAME	"Fast Deconvolution"
\end{lstlisting}


\clearpage

\nocite{*}
%Il comando \printbibliography produce la sezione bibliografica con relativi
%titolo e testatina. Per mandarne il relativo titolo nell’indice generale si
%usa l’istruzione:
\printbibliography

\end{document} 